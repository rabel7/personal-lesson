##锁的种类

*   公平锁/非公平锁
*   可重入锁
*   独享锁/共享锁
*   乐观锁/悲观锁
*   分段锁
*   自旋锁
http://m.jb51.net/article/122955.htm

---------------------------------------


#### 公平锁/非公平锁

公平锁可以保证线程安好申请的顺序获取锁，非公平则不行，在java中的实现是ReentrantLock（Synchronized也是一种非公平锁），
默认的构造函数使用的是非公平锁，传入true则为公平锁；非公平的优点在于性能更高，
但公平锁会避免出现饥饿现（当有线程正在读的时候，不允许写 线程写，但是允许其他的读线程进行读。
有写线程正在写的时候，其他的线程不应该读写。为了防止写线程出现饥饿现象，当线程正在读，如果写线程请求写，那么应该禁止再来的读线程进行读。）
和优先级反转（一个低优先级进程持有一个高优先级进程所需要的资源，使得高优先级进程等待低优先级进程运行）
优先级反转和饥饿现象文章：http://tutorials.jenkov.com/java-concurrency/starvation-and-fairness.html#performance

### 可重入锁

又称为递归锁，意思就是在嵌套方法内可以多次上锁，不会导致死锁，在java中所有的锁都是可重入锁，包括同步块也是

### 独享锁/共享锁

独享锁就是只能一个线程持有锁，比如reentrantLock就是独享锁，但是readWriteLock的读锁就是共享锁，写锁则为独享锁

### 乐观锁/悲观锁

悲观锁就是悲观的认为会有并发写的情况，一定要排队进行才不会产生并发问题，一般指的是数据库的锁
而乐观锁则是乐观的认为只会有一个线程在写的情况，一般以无锁编程（cas）自旋直到更新为止

### 分段锁

分段锁即为将锁分隔开，典型的例子就是concurrentHashMap，即将原本的bucket换成segment，通过计算key的hash值
确认在哪个segment，只对该segment进行加锁，不影响其他segment，此大大提高了并发

### 自旋锁

一般不采用线程阻塞的方式，而是采用不断循环的方式实现原子操作